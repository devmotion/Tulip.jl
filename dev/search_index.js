var documenterSearchIndex = {"docs":
[{"location":"manual/formulation/#Problem-formulation","page":"Problem formulation","title":"Problem formulation","text":"","category":"section"},{"location":"manual/formulation/#Model-input","page":"Problem formulation","title":"Model input","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Tulip takes as input LP problems of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrrcll\n    (P)    \n    displaystyle min_x  c^Tx  +  c_0\n    st\n     l^b_i leq  a_i^T x  leq u^b_i  forall i = 1  m\n     l^x_j leq  x_j  leq u^x_j  forall j = 1  n\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where l^bx u^b x in mathbbR cup  - infty + infty , i.e., some of the bounds may be infinite.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"This original formulation is then converted to standard form.","category":"page"},{"location":"manual/formulation/#Standard-form","page":"Problem formulation","title":"Standard form","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Internally, Tulip solves LPs of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrl\n    (P)    \n    displaystyle min_x\n     c^T x +  c_0\n    st\n     A x = b\n     l leq x leq u\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where x c in mathbbR^n, A in mathbbR^m times n, b in mathbbR^m, and  l u in (mathbbR cup -infty +infty )^n, i.e., some bounds may be infinite.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"The original problem is automatically reformulated into standard form before the optimization is performed. This transformation is transparent to the user.","category":"page"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameters can be queried and set through the get_parameter and set_parameter functions.","category":"page"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"In all that follows, epsilon refers to the numerical precision, which is given by eps(Tv) where Tv is the arithmetic of the current model. For instance, in double-precision arithmetic, i.e., Tv=Float64, we have epsilon simeq 10^-16.","category":"page"},{"location":"reference/parameters/#Tolerances","page":"Parameters","title":"Tolerances","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Numerical tolerances for the interior-point algorithm.","category":"page"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierTolerancePFeas Primal feasibility tolerance sqrtepsilon\nBarrierToleranceDFeas Dual feasibility tolerance sqrtepsilon\nBarrierToleranceRGap Relative optimality gap tolerance sqrtepsilon\nBarrierToleranceIFeas Infeasibility tolerance sqrtepsilon","category":"page"},{"location":"reference/parameters/#Algorithmic-parameters","page":"Parameters","title":"Algorithmic parameters","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierAlgorithm Interior-point algorithm 1\nBarrierCorrectionLimit Maximum number of additional centrality corrections 5\nBarrierStepDampFactor Step 0.9995\nBarrierGammaMin Minimum value of gamma for computing correctors 0.1\nBarrierCentralityOutlierThreshold Relative threshold for computing extra centrality corrections 0.1","category":"page"},{"location":"reference/parameters/#Stopping-criterion","page":"Parameters","title":"Stopping criterion","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierIterationsLimit Maximum number of barrier iterations 100\nTimeLimit Time limit, in seconds Inf","category":"page"},{"location":"reference/parameters/#Linear-algebra","page":"Parameters","title":"Linear algebra","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nMatrixOptions See TLA.MatrixOptions SparseMatrixCSC\nKKTOptions See KKT.SolverOptions KKT.Cholmod_SymQuasDef for Float64, KKT.LDLFact_SymQuasDef otherwise\nBarrierPRegMin Minimum value of primal regularization sqrtepsilon\nBarrierDregMin Minimum value of dual regularization sqrtepsilon","category":"page"},{"location":"reference/parameters/#Others","page":"Parameters","title":"Others","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nOutputLevel Controls the solver's output 0\nThreads Maximum number of threads 1\nPresolve Presolve (no presolve if set to ≤ 0) 1","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"reference/kkt_solvers/#Overview","page":"KKT solvers","title":"Overview","text":"","category":"section"},{"location":"reference/kkt_solvers/#AbstractKKTSolver","page":"KKT solvers","title":"AbstractKKTSolver","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"This is the base type from which all implementations should derive.","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"AbstractKKTSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.AbstractKKTSolver","page":"KKT solvers","title":"Tulip.KKT.AbstractKKTSolver","text":"AbstractKKTSolver{Tv}\n\nAbstract container for solving an augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nwhere ξd and ξp are given right-hand side.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Custom linear solvers should inherit from the AbstractKKTSolver class, and extend the following two functions:","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"update!","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.update!","page":"KKT solvers","title":"Tulip.KKT.update!","text":"update!(kkt, θinv, regP, regD)\n\nUpdate internal data and factorization/pre-conditioner.\n\nAfter this call, kkt can be used to solve the augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nfor given right-hand sides ξd and ξp.\n\nArguments\n\nkkt::AbstractKKTSolver{Tv}: the KKT solver object\nθinv::AbstractVector{Tv}: θ¹\nregP::AbstractVector{Tv}: primal regularizations\nregD::AbstractVector{Tv}: dual regularizations\n\n\n\n\n\n","category":"function"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"solve!","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.solve!","page":"KKT solvers","title":"Tulip.KKT.solve!","text":"solve!(dx, dy, kkt, ξp, ξd)\n\nSolve the symmetric quasi-definite augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nand over-write dx, dy with the result.\n\nArguments\n\ndx, dy: Vectors of unknowns, modified in-place\nkkt: Linear solver for the augmented system\nξp, ξd: Right-hand-side vectors\n\n\n\n\n\n","category":"function"},{"location":"reference/kkt_solvers/#Choosing-between-linear-solvers","page":"KKT solvers","title":"Choosing between linear solvers","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"SolverOptions","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.SolverOptions","page":"KKT solvers","title":"Tulip.KKT.SolverOptions","text":"SolverOptions\n\nUsed to pass options and instantiate KKT solvers.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"TLA.MatrixOptions","category":"page"},{"location":"reference/kkt_solvers/#Tulip.TLPLinearAlgebra.MatrixOptions","page":"KKT solvers","title":"Tulip.TLPLinearAlgebra.MatrixOptions","text":"MatrixOptions\n\nUsed to pass options for setting-up the matrix.\n\njulia> model = Tulip.Model{Float64}()\njulia> model.params.MatrixOptions = Tulip.TLA.MatrixOptions(SparseMatrixCSC)\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"reference/kkt_solvers/#Dense/LAPACK","page":"KKT solvers","title":"Dense/LAPACK","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Dense_SymPosDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.Dense_SymPosDef","page":"KKT solvers","title":"Tulip.KKT.Dense_SymPosDef","text":"Dense_SymPosDef{Tv}\n\nKKT solver for dense linear systems.\n\nUses a Cholesky factorization of the normal equations system. Not recommended     for systems of size larger than a few thousands.\n\nmodel = Tulip.Model{Float64}()\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(Tulip.KKT.Dense_SymPosDef)\n\ninfo: Info\nDispatches to BLAS/LAPACK in Float32 and Float64 arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/#CHOLMOD","page":"KKT solvers","title":"CHOLMOD","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CholmodSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.CholmodSolver","page":"KKT solvers","title":"Tulip.KKT.CholmodSolver","text":"CholmodSolver\n\nUses CHOLMOD's factorization routines to solve the augmented system.\n\nTo use an LDLᵀ factorization of the augmented system (see Cholmod_SymQuasDef)\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(CholmodSolver, normal_equations=false)\n\nTo use a Cholesky factorization of the normal equations system (see Cholmod_SymPosDef)\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(CholmodSolver, normal_equations=true)\n\nwarning: Warning\nCHOLMOD can only be used with Float64 arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Cholmod_SymQuasDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.Cholmod_SymQuasDef","page":"KKT solvers","title":"Tulip.KKT.Cholmod_SymQuasDef","text":"Cholmod_SymQuasDef\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses an LDLᵀ factorization of the quasi-definite augmented system.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Cholmod_SymPosDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.Cholmod_SymPosDef","page":"KKT solvers","title":"Tulip.KKT.Cholmod_SymPosDef","text":"Cholmod_SymPosDef\n\nLinear solver for the 2x2 augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [xi_d]\n    [   A          Rd] [dy]   [xi_p]\n\nwith A sparse.\n\nUses a Cholesky factorization of the positive definite normal equations system\n\n(A * ((Θ⁻¹ + Rp)⁻¹ * Aᵀ + Rd) dy = xi_p + A * (θ⁻¹ + Rp)⁻¹ * xi_d\n                              dx = (Θ⁻¹ + Rp)⁻¹ * (Aᵀ * dy - xi_d)\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/#LDLFactorizations","page":"KKT solvers","title":"LDLFactorizations","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"LDLFact_SymQuasDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.LDLFact_SymQuasDef","page":"KKT solvers","title":"Tulip.KKT.LDLFact_SymQuasDef","text":"LDLFact_SymQuasDef{Tv}\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses LDLFactorizations.jl to compute an LDLᵀ factorization of the quasi-definite augmented system.\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(LDLFact_SymQuasDef)\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/#Krylov","page":"KKT solvers","title":"Krylov","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"warning: Warning\nIterative methods are still an experimental feature. Some numerical and performance issues should be expected.","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSPDSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.KrylovSPDSolver","page":"KKT solvers","title":"Tulip.KKT.KrylovSPDSolver","text":"KrylovSPDSolver{T, F, Tv, Ta}\n\nKrylov-based Symmetric Positive-Definite (SPD) linear solver.\n\nApplies a Krylov method to the normal equations systems, then recovers a solution to the augmented system. The selected Krylov method must therefore handle symmetric positive-definite systems. Suitable methods are CG or CR.\n\nA KrylovSPDSolver is selected as follows\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(\n    KrylovSPDSolver, method=Krylov.cg,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\ndy, _ = f(S, ξ; atol, rtol)\n\nwhere S, ξ and dy are the normal equations system's left- and right-hand side, and solution vector, respectively. S may take the form of a matrix, or of a suitable linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSIDSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.KrylovSIDSolver","page":"KKT solvers","title":"Tulip.KKT.KrylovSIDSolver","text":"KrylovSIDSolver{T, F, Tv, Ta}\n\nKrylov-based Symmetric InDefinite (SID) linear solver.\n\nApplies a Krylov method to solve the augmented system, without exploiting its quasi-definiteness properties. The selected Krylov method must therefore handle symmetric indefinite systems. Suitable methods are MINRES or MINRES-QLP.\n\nA KrylovSIDSolver is selected as follows\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(\n    KrylovSIDSolver, method=Krylov.minres,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\nΔ, _ = f(K, ξ; atol, rtol)\n\nwhere K, ξ and Δ are the augmented system's left- and right-hand side, and solution vector, respectively. K may take the form of a matrix, or of a suitable linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSQDSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.KrylovSQDSolver","page":"KKT solvers","title":"Tulip.KKT.KrylovSQDSolver","text":"KrylovSQDSolver{T, F, Tv, Ta}\n\nKrylov-based Symmetric Quasi-Definite (SQD) linear solver.\n\nApplies a Krylov method to solve the augmented system, taking advantage of its 2x2 block structure and quasi-definiteness. The selected Krylov method must therefore handle 2x2 symmetric quasi-definite systems. Suitable methods are TriCG and TriMR.\n\nA KrylovSIDSolver is selected as follows\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(\n    KrylovSQDSolver, method=Krylov.trimr,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\ndy, dx, _ = f(A, ξp, ξd; M, N, atol, rtol)\n\nwhere the augmented system is of the form\n\n[ -N⁻¹ Aᵀ ] [dx] = [ξd]\n[  A   M⁻¹] [dy] = [ξp]\n\ni.e., N = (Θ^-1 + R_p)^-1 and M = R_d^-1.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/lp_example/#Toy-example","page":"Toy example","title":"Toy example","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"Tulip can be accessed in 3 ways: through JuMP, through MathOptInterface, or directly.","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"This tutorial illustrates, for each case, how to build a model, solve it, and query the solution value. In all cases, we consider the small LP","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"beginarrayrrrl\n    (LP)    \n    displaystyle Z^* = min_x y  -2x  - y\n    st\n      x  - y  geq -2\n     2x -  y  leq  4\n      x + 2y  leq  7\n      x   y  geq  0\nendarray","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"whose optimal value and solution are Z^* = -8 and (x^* y^*) = (3 2).","category":"page"},{"location":"tutorials/lp_example/#JuMP","page":"Toy example","title":"JuMP","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\nusing JuMP\nimport Tulip\n\n# Instantiate JuMP model\nlp = Model(Tulip.Optimizer)\n\n# Create variables\n@variable(lp, x >= 0)\n@variable(lp, y >= 0)\n\n# Add constraints\n@constraint(lp, row1, x - y >= -2)\n@constraint(lp, row2, 2*x - y <= 4)\n@constraint(lp, row3, x + 2*y <= 7)\n\n# Set the objective\n@objective(lp, Min, -2*x - y)\n\n# Set some parameters\nset_optimizer_attribute(lp, \"OutputLevel\", 0)  # disable output\nset_optimizer_attribute(lp, \"Presolve\", 0)     # disable presolve\n\n# Solve the problem\noptimize!(lp)\n\n# Check termination status\nst = termination_status(lp)\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = objective_value(lp)\nx_ = value(x)\ny_ = value(y)\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"tutorials/lp_example/#MOI","page":"Toy example","title":"MOI","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\n\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nimport Tulip\n\nlp = Tulip.Optimizer{Float64}()\n\n# Create variables\nx = MOI.add_variable(lp)\ny = MOI.add_variable(lp)\n\n# Set variable bounds\nMOI.add_constraint(lp, MOI.SingleVariable(x), MOI.GreaterThan(0.0))  # x >= 0\nMOI.add_constraint(lp, MOI.SingleVariable(y), MOI.GreaterThan(0.0))  # y >= 0\n\n# Add constraints\nrow1 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1.0, -1.0], [x, y]), 0.0),\n    MOI.GreaterThan(-2.0)\n)\nrow2 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([2.0, -1.0], [x, y]), 0.0),\n    MOI.LessThan(4.0)\n)\nrow3 = MOI.add_constraint(lp,\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1.0,  2.0], [x, y]), 0.0),\n    MOI.LessThan(7.0)\n) \n\n# Set the objective\nMOI.set(lp,\n    MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([-2.0, -1.0], [x, y]), 0.0)\n)\nMOI.set(lp, MOI.ObjectiveSense(), MOI.MIN_SENSE)\n\n# Set some parameters\nMOI.set(lp, MOI.Silent(), true)               # disable output\nMOI.set(lp, MOI.RawParameter(\"Presolve\"), 0)  # disable presolve\n\n# Solve the problem\nMOI.optimize!(lp)\n\n# Check status\nst = MOI.get(lp, MOI.TerminationStatus())\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = MOI.get(lp, MOI.ObjectiveValue())\nx_ = MOI.get(lp, MOI.VariablePrimal(), x)\ny_ = MOI.get(lp, MOI.VariablePrimal(), y)\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"tutorials/lp_example/#Tulip","page":"Toy example","title":"Tulip","text":"","category":"section"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"warning: Warning\nTulip's low-level API should not be considered stable nor complete. The recommended way to use Tulip is through JuMP/MOI as shown above.","category":"page"},{"location":"tutorials/lp_example/","page":"Toy example","title":"Toy example","text":"using Printf\nimport Tulip\n\n# Instantiate Tulip object\nlp = Tulip.Model{Float64}()\npb = lp.pbdata  # Internal problem data\n\n# Create variables\nx = Tulip.add_variable!(pb, Int[], Float64[], -2.0, 0.0, Inf, \"x\")\ny = Tulip.add_variable!(pb, Int[], Float64[], -1.0, 0.0, Inf, \"y\")\n\n# Add constraints\nrow1 = Tulip.add_constraint!(pb, [x, y], [1.0, -1.0], -2.0, Inf, \"row1\")\nrow2 = Tulip.add_constraint!(pb, [x, y], [2.0, -1.0], -Inf, 4.0, \"row2\")\nrow3 = Tulip.add_constraint!(pb, [x, y], [1.0,  2.0], -Inf, 7.0, \"row3\")\n\n# Set the objective\n# Nothing to do here as objective is already declared\n\n# Set some parameters\nTulip.set_parameter(lp, \"OutputLevel\", 0)  # disable output\nTulip.set_parameter(lp, \"Presolve\", 0)     # disable presolve\n\n# Solve the problem\nTulip.optimize!(lp)\n\n# Check termination status\nst = Tulip.get_attribute(lp, Tulip.Status())\nprintln(\"Termination status: $st\")\n\n# Query solution value\nobjval = Tulip.get_attribute(lp, Tulip.ObjectiveValue())\nx_ = lp.solution.x[x]\ny_ = lp.solution.x[y]\n\n@printf \"Z* = %.4f\\n\" objval\n@printf \"x* = %.4f\\n\" x_\n@printf \"y* = %.4f\\n\" y_","category":"page"},{"location":"reference/API/","page":"Julia API","title":"Julia API","text":"Modules = [Tulip]\nPages = [\"tulip_julia_api.jl\"]","category":"page"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.BarrierIterations}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::BarrierIterations)\n\nQuery the BarrierIterations attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::ConstraintName, i::Int)\n\nQuery the name of constraint i in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ModelName}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ModelName)\n\nQuery the ModelName attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.Status}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::Status)\n\nQuery the Status attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableLowerBound,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model{Tv}, ::VariableLowerBound, j::Int)\n\nQuery the lower bound of variable j in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::VariableName, j::Int)\n\nQuery the name of variable j in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.DualObjectiveValue}} where Tv","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::DualObjectiveValue)\n\nQuery the DualObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ObjectiveValue}} where Tv","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ObjectiveValue)\n\nQuery the ObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_parameter-Tuple{Tulip.Model,String}","page":"Julia API","title":"Tulip.get_parameter","text":"get_parameter(m::Model, pname::String)\n\nQuery the value of parameter pname in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.load_problem!-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},String}} where Tv","page":"Julia API","title":"Tulip.load_problem!","text":"load_problem!(m::Model{Tv}, fname::String)\n\nRead a model from file fname and load it into model m.\n\nOnly free MPS files are currently supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::ConstraintName, i::Int, name::String)\n\nSet the name of constraint i in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ModelName,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(model::Model, ::ModelName, name::String)\n\nSet the ModelName attribute in model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::VariableName, j::Int, name::String)\n\nSet the name of variable j in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ConstraintLowerBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::ConstraintLowerBound, i::Int, lb::Tv)\n\nSet the lower bound of constraint i in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ConstraintUpperBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::ConstraintUpperBound, i::Int, ub::Tv)\n\nSet the upper bound of constraint i in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.VariableLowerBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::VariableLowerBound, j::Int, lb::Tv)\n\nSet the lower bound of variable j in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.VariableUpperBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::VariableUpperBound, j::Int, ub::Tv)\n\nSet the upper bound of variable j in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_parameter-Tuple{Tulip.Model,String,Any}","page":"Julia API","title":"Tulip.set_parameter","text":"set_parameter(m::Model, pname::String, val)\n\nSet the value of parameter pname in model m to val\n\n\n\n\n\n","category":"method"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"manual/linear_systems/#Solving-linear-systems","page":"Solving linear systems","title":"Solving linear systems","text":"","category":"section"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"The interior-point algorithm in Tulip requires the solution, at each iteration, of the following symmetric quasi-definite augmented system","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"beginbmatrix\n    -(Theta^-1 + R_p)  A^T\n    A  R_d\nendbmatrix\nbeginbmatrix\n    Delta x\n    Delta y\nendbmatrix\n=\nbeginbmatrix\n    xi_d\n    xi_p\nendbmatrix","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"where","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Delta x Delta y are primal and dual search directions,\nA is the problem's constraint matrix,\nTheta, R_p and R_d are positive diagonal matrices,\nxi_p xi_d are right-hand side vectors.","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"The augmented system above can be reduced to the positive-definite normal equations system","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"beginarrayrl\nleft(\n    A (Theta^-1 + R_p)^-1 A^T + R_d\nright)\nDelta y\n =\nxi_p + A (Θ^-1 + R_p)^-1 xi_d\nDelta x = (Θ^-1 + R_p)^-1 (A^T Delta y - xi_d)\nendarray","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"If available and when selected, this reduction is transparent to the interior-point algorithm.","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"To enable the use of fast external libraries and/or specialized routines, the resolution of linear systems is performed by an [AbstractKKTSolver] object.","category":"page"},{"location":"manual/linear_systems/#Supported-linear-solvers","page":"Solving linear systems","title":"Supported linear solvers","text":"","category":"section"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Here is a list of currently supported linear solvers:","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Linear solver type System Backend Method\nDense_SymPosDef Normal equations Dense / LAPACK Cholesky\nCholmod_SymQuasDef Augmented system CHOLMOD LDLᵀ\nCholmod_SymPosDef Normal equations CHOLMOD Cholesky\nLDLFact_SymQuasDef Augmented system LDLFactorizations.jl LDLᵀ\nKrylovSPDSolver Normal equations Krylov.jl Krylov\nKrylovSIDSolver Augmented system[1] Krylov.jl Krylov\nKrylovSQDSolver Augmented system[1] Krylov.jl Krylov","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"[1]: KrylovSIDSolvers view the augmented system as a symmetric indefinite system, while KrylovSQDSolvers exploit its 2x2 structure and quasi-definite property. See the reference documentation for more details.","category":"page"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/attributes/#Attribute-reference","page":"Attributes","title":"Attribute reference","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Attributes are queried using get_attribute and set using set_attribute.","category":"page"},{"location":"reference/attributes/#Model-attributes","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nModelName String Name of the model\nNumberOfConstraints Int Number of constraints in the model\nNumberOfVariables Int Number of variables in the model\nObjectiveValue T Objective value of the current primal solution\nDualObjectiveValue T Objective value of the current dual solution\nObjectiveConstant T Value of the objective constant\nObjectiveSense  Optimization sense\nStatus  Model status\nBarrierIterations Int Number of barrier iterations\nSolutionTime Float64 Solution time, in seconds","category":"page"},{"location":"reference/attributes/#Variable-attributes","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nVariableLowerBound T Variable lower bound\nVariableUpperBound T Variable upper bound\nVariableObjectiveCoeff T Variable objective coefficient\nVariableName String Variable name","category":"page"},{"location":"reference/attributes/#Constraint-attributes","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nConstraintLowerBound T Constraint lower bound\nConstraintUpperBound T Constraint upper bound\nConstraintName String Constraint name","category":"page"},{"location":"reference/attributes/#Reference","page":"Attributes","title":"Reference","text":"","category":"section"},{"location":"reference/attributes/#Model-attributes-2","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractModelAttribute","category":"page"},{"location":"reference/attributes/#Tulip.BarrierIterations","page":"Attributes","title":"Tulip.BarrierIterations","text":"BarrierIterations\n\nNumber of iterations of the barrier algorithm in the last call.\n\nThis number may be zero in the following cases:\n\nthe model has been solved yet\npresolve solved the model\nthe initial solution was optimal\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.BarrierIterations())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.DualObjectiveValue","page":"Attributes","title":"Tulip.DualObjectiveValue","text":"DualObjectiveValue\n\nObjective value of the current dual solution.\n\nType: T\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.DualObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ModelName","page":"Attributes","title":"Tulip.ModelName","text":"ModelName\n\nThe name of the model.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ModelName(), \"lp_example\")\nTulip.get_attribute(model, Tulip.ModelName())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfConstraints","page":"Attributes","title":"Tulip.NumberOfConstraints","text":"NumberOfConstraints\n\nNumber of constraints in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfConstraints())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfVariables","page":"Attributes","title":"Tulip.NumberOfVariables","text":"NumberOfVariables\n\nNumber of variables in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfVariables())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveConstant","page":"Attributes","title":"Tulip.ObjectiveConstant","text":"ObjectiveConstant\n\nConstant objective offset, defaults to zero.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ObjectiveConstant(), zero(T))\nTulip.get_attribute(model, Tulip.ObjectiveConstant())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveSense","page":"Attributes","title":"Tulip.ObjectiveSense","text":"ObjectiveSense\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveValue","page":"Attributes","title":"Tulip.ObjectiveValue","text":"ObjectiveValue\n\nObjective value of the current primal solution.\n\nType: T\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.ObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.SolutionTime","page":"Attributes","title":"Tulip.SolutionTime","text":"SolutionTime\n\nTotal solution time, in seconds.\n\nType: Float64\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.SolutionTime())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.Status","page":"Attributes","title":"Tulip.Status","text":"Status\n\nModel status\n\nType:\n\nModifiable: No\n\nExamples\n\nTulip.get(model, Tulip.Status())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Variable-attributes-2","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractVariableAttribute","category":"page"},{"location":"reference/attributes/#Tulip.VariableLowerBound","page":"Attributes","title":"Tulip.VariableLowerBound","text":"VariableLowerBound\n\nVariable lower bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableLowerBound(), 1, zero(T))\nTulip.get_attribute(model, Tulip.VariableLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableName","page":"Attributes","title":"Tulip.VariableName","text":"VariableName\n\nName of the variable.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableName(), 1, \"x1\")\nTulip.get_attribute(model, Tulip.VariableName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableObjectiveCoeff","page":"Attributes","title":"Tulip.VariableObjectiveCoeff","text":"VariableObjectiveCoeff\n\nObjective coefficient of the variable.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableObjectiveCoeff(), 1, one(T))\nTulip.get_attribute(model, Tulip.VariableObjectiveCoeff(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableUpperBound","page":"Attributes","title":"Tulip.VariableUpperBound","text":"VariableUpperBound\n\nVariable upper bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableUpperBound(), 1, one(T))\nTulip.get_attribute(model, Tulip.VariableUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Constraint-attributes-2","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractConstraintAttribute","category":"page"},{"location":"reference/attributes/#Tulip.ConstraintLowerBound","page":"Attributes","title":"Tulip.ConstraintLowerBound","text":"ConstraintLowerBound\n\nConstraint lower bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintLowerBound(), 1, zero(T))\nTulip.get_attribute(model, Tulip.ConstraintLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintName","page":"Attributes","title":"Tulip.ConstraintName","text":"ConstraintName\n\nName of the constraint.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintName(), 1, \"c1\")\nTulip.get_attribute(model, Tulip.ConstraintName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintUpperBound","page":"Attributes","title":"Tulip.ConstraintUpperBound","text":"ConstraintUpperBound\n\nConstraint upper bound.\n\nType: T\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintUpperBound(), 1, one(T))\nTulip.get_attribute(model, Tulip.ConstraintUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Tulip","category":"page"},{"location":"#Tulip.jl","page":"Home","title":"Tulip.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is an open-source interior-point solver for linear programming.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is 100% Julia, so install it just like any Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add Tulip","category":"page"},{"location":"","page":"Home","title":"Home","text":"No additional building step is required.","category":"page"},{"location":"#Citing-Tulip.jl","page":"Home","title":"Citing Tulip.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Tulip in your work, we kindly ask that you cite the following reference. The PDF is freely available here, and serves as a user manual for advanced users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@TechReport{Tulip.jl,\n    title = {{Tulip}.jl: an open-source interior-point linear optimization\n    solver with abstract linear algebra},\n    url = {https://www.gerad.ca/fr/papers/G-2019-36},\n    Journal = {Les Cahiers du Gerad},\n    Author = {Anjos, Miguel F. and Lodi, Andrea and Tanneau, Mathieu},\n    year = {2019}\n}","category":"page"}]
}
