var documenterSearchIndex = {"docs":
[{"location":"manual/formulation/#Problem-formulation","page":"Problem formulation","title":"Problem formulation","text":"","category":"section"},{"location":"manual/formulation/#Model-input","page":"Problem formulation","title":"Model input","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Tulip takes as input LP problems of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrrcll\n    (P)    \n    displaystyle min_x  c^Tx  +  c_0\n    st\n     l^b_i leq  a_i^T x  leq u^b_i  forall i = 1  m\n     l^x_j leq  x_j  leq u^x_j  forall j = 1  n\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where l^bx u^b x in mathbbR cup  - infty + infty , i.e., some of the bounds may be infinite.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"This original formulation is then converted to standard form.","category":"page"},{"location":"manual/formulation/#Standard-form","page":"Problem formulation","title":"Standard form","text":"","category":"section"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"Internally, Tulip solves LPs of the form","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"    beginarrayrl\n    (P)    \n    displaystyle min_x\n     c^T x +  c_0\n    st\n     A x = b\n     x leq u\n     x geq 0\n    endarray","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"where x c u in mathbbR^n, A in mathbbR^m times n and b in mathbbR^m. Some u_j may may take infinite value, i.e., the corresponding variable x_j has no upper bound.","category":"page"},{"location":"manual/formulation/","page":"Problem formulation","title":"Problem formulation","text":"The original problem is automatically reformulated into standard form before the optimization is performed. This transformation is transparent to the user.","category":"page"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameters can be queried and set through the get_parameter and set_parameter functions.","category":"page"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"In all that follows, epsilon refers to the numerical precision, which is given by eps(Tv) where Tv is the arithmetic of the current model. For instance, in double-precision arithmetic, i.e., Tv=Float64, we have epsilon simeq 10^-16.","category":"page"},{"location":"reference/parameters/#Tolerances","page":"Parameters","title":"Tolerances","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Numerical tolerances for the interior-point algorithm.","category":"page"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierTolerancePFeas Primal feasibility tolerance sqrtepsilon\nBarrierToleranceDFeas Dual feasibility tolerance sqrtepsilon\nBarrierToleranceRGap Relative optimality gap tolerance sqrtepsilon\nBarrierToleranceIFeas Infeasibility tolerance sqrtepsilon","category":"page"},{"location":"reference/parameters/#Algorithmic-parameters","page":"Parameters","title":"Algorithmic parameters","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierAlgorithm Interior-point algorithm 1\nBarrierCorrectionLimit Maximum number of additional centrality corrections 5\nBarrierStepDampFactor Step 0.9995\nBarrierGammaMin Minimum value of gamma for computing correctors 0.1\nBarrierCentralityOutlierThreshold Relative threshold for computing extra centrality corrections 0.1","category":"page"},{"location":"reference/parameters/#Stopping-criterion","page":"Parameters","title":"Stopping criterion","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nBarrierIterationsLimit Maximum number of barrier iterations 100\nTimeLimit Time limit, in seconds Inf","category":"page"},{"location":"reference/parameters/#Linear-algebra","page":"Parameters","title":"Linear algebra","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nMatrixOptions See TLA.MatrixOptions SparseMatrixCSC\nKKTOptions See KKT.SolverOptions KKT.Cholmod_SymQuasDef for Float64, KKT.LDLFact_SymQuasDef otherwise\nBarrierPRegMin Minimum value of primal regularization sqrtepsilon\nBarrierDregMin Minimum value of dual regularization sqrtepsilon","category":"page"},{"location":"reference/parameters/#Others","page":"Parameters","title":"Others","text":"","category":"section"},{"location":"reference/parameters/","page":"Parameters","title":"Parameters","text":"Parameter Description Default\nOutputLevel Controls the solver's output 0\nThreads Maximum number of threads 1\nPresolve Presolve (no presolve if set to ≤ 0) 1","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"reference/kkt_solvers/#Overview","page":"KKT solvers","title":"Overview","text":"","category":"section"},{"location":"reference/kkt_solvers/#AbstractKKTSolver","page":"KKT solvers","title":"AbstractKKTSolver","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"This is the base type from which all implementations should derive.","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"AbstractKKTSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.AbstractKKTSolver","page":"KKT solvers","title":"Tulip.KKT.AbstractKKTSolver","text":"AbstractKKTSolver{Tv}\n\nAbstract container for solving an augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nwhere ξd and ξp are given right-hand side.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Custom linear solvers should inherit from the AbstractKKTSolver class, and extend the following two functions:","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"update!","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.update!","page":"KKT solvers","title":"Tulip.KKT.update!","text":"update!(kkt, θinv, regP, regD)\n\nUpdate internal data and factorization/pre-conditioner.\n\nAfter this call, kkt can be used to solve the augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nfor given right-hand sides ξd and ξp.\n\nArguments\n\nkkt::AbstractKKTSolver{Tv}: the KKT solver object\nθinv::AbstractVector{Tv}: θ¹\nregP::AbstractVector{Tv}: primal regularizations\nregD::AbstractVector{Tv}: dual regularizations\n\n\n\n\n\n","category":"function"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"solve!","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.solve!","page":"KKT solvers","title":"Tulip.KKT.solve!","text":"solve!(dx, dy, kkt, ξp, ξd)\n\nSolve the symmetric quasi-definite augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [ξd]\n    [   A          Rd] [dy]   [ξp]\n\nand over-write dx, dy with the result.\n\nArguments\n\ndx, dy: Vectors of unknowns, modified in-place\nkkt: Linear solver for the augmented system\nξp, ξd: Right-hand-side vectors\n\n\n\n\n\n","category":"function"},{"location":"reference/kkt_solvers/#Choosing-between-linear-solvers","page":"KKT solvers","title":"Choosing between linear solvers","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"SolverOptions","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.SolverOptions","page":"KKT solvers","title":"Tulip.KKT.SolverOptions","text":"SolverOptions\n\nUsed to pass options and instantiate KKT solvers.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"TLA.MatrixOptions","category":"page"},{"location":"reference/kkt_solvers/#Tulip.TLPLinearAlgebra.MatrixOptions","page":"KKT solvers","title":"Tulip.TLPLinearAlgebra.MatrixOptions","text":"MatrixOptions\n\nUsed to pass options for setting-up the matrix.\n\njulia> model = Tulip.Model{Float64}()\njulia> model.params.MatrixOptions = Tulip.TLA.MatrixOptions(SparseMatrixCSC)\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"reference/kkt_solvers/#Dense/LAPACK","page":"KKT solvers","title":"Dense/LAPACK","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Dense_SymPosDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.Dense_SymPosDef","page":"KKT solvers","title":"Tulip.KKT.Dense_SymPosDef","text":"Dense_SymPosDef{Tv}\n\nKKT solver for dense linear systems.\n\nUses a Cholesky factorization of the normal equations system. Not recommended     for systems of size larger than a few thousands.\n\nmodel = Tulip.Model{Float64}()\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(Tulip.KKT.Dense_SymPosDef)\n\ninfo: Info\nDispatches to BLAS/LAPACK in Float32 and Float64 arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/#CHOLMOD","page":"KKT solvers","title":"CHOLMOD","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"CholmodSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.CholmodSolver","page":"KKT solvers","title":"Tulip.KKT.CholmodSolver","text":"CholmodSolver\n\nUses CHOLMOD's factorization routines to solve the augmented system.\n\nTo use an LDLᵀ factorization of the augmented system (see Cholmod_SymQuasDef)\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(CholmodSolver, normal_equations=false)\n\nTo use a Cholesky factorization of the normal equations system (see Cholmod_SymPosDef)\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(CholmodSolver, normal_equations=true)\n\nwarning: Warning\nCHOLMOD can only be used with Float64 arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Cholmod_SymQuasDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.Cholmod_SymQuasDef","page":"KKT solvers","title":"Tulip.KKT.Cholmod_SymQuasDef","text":"Cholmod_SymQuasDef\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses an LDLᵀ factorization of the quasi-definite augmented system.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"Cholmod_SymPosDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.Cholmod_SymPosDef","page":"KKT solvers","title":"Tulip.KKT.Cholmod_SymPosDef","text":"Cholmod_SymPosDef\n\nLinear solver for the 2x2 augmented system\n\n    [-(Θ⁻¹ + Rp)   Aᵀ] [dx] = [xi_d]\n    [   A          Rd] [dy]   [xi_p]\n\nwith A sparse.\n\nUses a Cholesky factorization of the positive definite normal equations system\n\n(A * ((Θ⁻¹ + Rp)⁻¹ * Aᵀ + Rd) dy = xi_p + A * (θ⁻¹ + Rp)⁻¹ * xi_d\n                              dx = (Θ⁻¹ + Rp)⁻¹ * (Aᵀ * dy - xi_d)\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/#LDLFactorizations","page":"KKT solvers","title":"LDLFactorizations","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"LDLFact_SymQuasDef","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.LDLFact_SymQuasDef","page":"KKT solvers","title":"Tulip.KKT.LDLFact_SymQuasDef","text":"LDLFact_SymQuasDef{Tv}\n\nLinear solver for the 2x2 augmented system with A sparse.\n\nUses LDLFactorizations.jl to compute an LDLᵀ factorization of the quasi-definite augmented system.\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(LDLFact_SymQuasDef)\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/#Krylov","page":"KKT solvers","title":"Krylov","text":"","category":"section"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"warning: Warning\nIterative methods are still an experimental feature. Some numerical and performance issues should be expected.","category":"page"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSPDSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.KrylovSPDSolver","page":"KKT solvers","title":"Tulip.KKT.KrylovSPDSolver","text":"KrylovSPDSolver{T, F, Tv, Ta}\n\nKrylov-based Symmetric Positive-Definite (SPD) linear solver.\n\nApplies a Krylov method to the normal equations systems, then recovers a solution to the augmented system. The selected Krylov method must therefore handle symmetric positive-definite systems. Suitable methods are CG or CR.\n\nA KrylovSPDSolver is selected as follows\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(\n    KrylovSPDSolver, method=Krylov.cg,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\ndy, _ = f(S, ξ; atol, rtol)\n\nwhere S, ξ and dy are the normal equations system's left- and right-hand side, and solution vector, respectively. S may take the form of a matrix, or of a suitable linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSIDSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.KrylovSIDSolver","page":"KKT solvers","title":"Tulip.KKT.KrylovSIDSolver","text":"KrylovSIDSolver{T, F, Tv, Ta}\n\nKrylov-based Symmetric InDefinite (SID) linear solver.\n\nApplies a Krylov method to solve the augmented system, without exploiting its quasi-definiteness properties. The selected Krylov method must therefore handle symmetric indefinite systems. Suitable methods are MINRES or MINRES-QLP.\n\nA KrylovSIDSolver is selected as follows\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(\n    KrylovSIDSolver, method=Krylov.minres,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\nΔ, _ = f(K, ξ; atol, rtol)\n\nwhere K, ξ and Δ are the augmented system's left- and right-hand side, and solution vector, respectively. K may take the form of a matrix, or of a suitable linear operator.\n\n\n\n\n\n","category":"type"},{"location":"reference/kkt_solvers/","page":"KKT solvers","title":"KKT solvers","text":"KrylovSQDSolver","category":"page"},{"location":"reference/kkt_solvers/#Tulip.KKT.KrylovSQDSolver","page":"KKT solvers","title":"Tulip.KKT.KrylovSQDSolver","text":"KrylovSQDSolver{T, F, Tv, Ta}\n\nKrylov-based Symmetric Quasi-Definite (SQD) linear solver.\n\nApplies a Krylov method to solve the augmented system, taking advantage of its 2x2 block structure and quasi-definiteness. The selected Krylov method must therefore handle 2x2 symmetric quasi-definite systems. Suitable methods are TriCG and TriMR.\n\nA KrylovSIDSolver is selected as follows\n\nmodel.params.KKTOptions = Tulip.KKT.SolverOptions(\n    KrylovSQDSolver, method=Krylov.trimr,\n    atol=1e-12, rtol=1e-12\n)\n\nThe method argument is a function f::F whose signature must match\n\ndy, dx, _ = f(A, ξp, ξd; M, N, atol, rtol)\n\nwhere the augmented system is of the form\n\n[ -N⁻¹ Aᵀ ] [dx] = [ξd]\n[  A   M⁻¹] [dy] = [ξp]\n\ni.e., N = (Θ^-1 + R_p)^-1 and M = R_d^-1.\n\n\n\n\n\n","category":"type"},{"location":"reference/API/","page":"Julia API","title":"Julia API","text":"Modules = [Tulip]\nPages = [\"tulip_julia_api.jl\"]","category":"page"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.BarrierIterations}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::BarrierIterations)\n\nQuery the BarrierIterations attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::ConstraintName, i::Int)\n\nQuery the name of constraint i in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.ModelName}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ModelName)\n\nQuery the ModelName attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.Status}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::Status)\n\nQuery the Status attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableLowerBound,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model{Tv}, ::VariableLowerBound, j::Int)\n\nQuery the lower bound of variable j in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64}","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(m::Model, ::VariableName, j::Int)\n\nQuery the name of variable j in model m\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.DualObjectiveValue}} where Tv","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::DualObjectiveValue)\n\nQuery the DualObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ObjectiveValue}} where Tv","page":"Julia API","title":"Tulip.get_attribute","text":"get_attribute(model::Model, ::ObjectiveValue)\n\nQuery the ObjectiveValue attribute from model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.get_parameter-Tuple{Tulip.Model,String}","page":"Julia API","title":"Tulip.get_parameter","text":"get_parameter(m::Model, pname::String)\n\nQuery the value of parameter pname in model m.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.load_problem!-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},String}} where Tv","page":"Julia API","title":"Tulip.load_problem!","text":"load_problem!(m::Model{Tv}, fname::String)\n\nRead a model from file fname and load it into model m.\n\nOnly free MPS files are currently supported.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ConstraintName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::ConstraintName, i::Int, name::String)\n\nSet the name of constraint i in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.ModelName,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(model::Model, ::ModelName, name::String)\n\nSet the ModelName attribute in model\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Tuple{Tulip.Model,Tulip.VariableName,Int64,String}","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model, ::VariableName, j::Int, name::String)\n\nSet the name of variable j in model m to name.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ConstraintLowerBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::ConstraintLowerBound, i::Int, lb::Tv)\n\nSet the lower bound of constraint i in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.ConstraintUpperBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::ConstraintUpperBound, i::Int, ub::Tv)\n\nSet the upper bound of constraint i in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.VariableLowerBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::VariableLowerBound, j::Int, lb::Tv)\n\nSet the lower bound of variable j in model m to lb.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_attribute-Union{Tuple{Tv}, Tuple{Tulip.Model{Tv},Tulip.VariableUpperBound,Int64,Tv}} where Tv","page":"Julia API","title":"Tulip.set_attribute","text":"set_attribute(m::Model{Tv}, ::VariableUpperBound, j::Int, ub::Tv)\n\nSet the upper bound of variable j in model m to ub.\n\n\n\n\n\n","category":"method"},{"location":"reference/API/#Tulip.set_parameter-Tuple{Tulip.Model,String,Any}","page":"Julia API","title":"Tulip.set_parameter","text":"set_parameter(m::Model, pname::String, val)\n\nSet the value of parameter pname in model m to val\n\n\n\n\n\n","category":"method"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"CurrentModule = Tulip.KKT","category":"page"},{"location":"manual/linear_systems/#Solving-linear-systems","page":"Solving linear systems","title":"Solving linear systems","text":"","category":"section"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"The interior-point algorithm in Tulip requires the solution, at each iteration, of the following symmetric quasi-definite augmented system","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"beginbmatrix\n    -(Theta^-1 + R_p)  A^T\n    A  R_d\nendbmatrix\nbeginbmatrix\n    Delta x\n    Delta y\nendbmatrix\n=\nbeginbmatrix\n    xi_d\n    xi_p\nendbmatrix","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"where","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Delta x Delta y are primal and dual search directions,\nA is the problem's constraint matrix,\nTheta, R_p and R_d are positive diagonal matrices,\nxi_p xi_d are right-hand side vectors.","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"The augmented system above can be reduced to the positive-definite normal equations system","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"beginarrayrl\nleft(\n    A (Theta^-1 + R_p)^-1 A^T + R_d\nright)\nDelta y\n =\nxi_p + A (Θ^-1 + R_p)^-1 xi_d\nDelta x = (Θ^-1 + R_p)^-1 (A^T Delta y - xi_d)\nendarray","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"If available and when selected, this reduction is transparent to the interior-point algorithm.","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"To enable the use of fast external libraries and/or specialized routines, the resolution of linear systems is performed by an [AbstractKKTSolver] object.","category":"page"},{"location":"manual/linear_systems/#Supported-linear-solvers","page":"Solving linear systems","title":"Supported linear solvers","text":"","category":"section"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Here is a list of currently supported linear solvers:","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"Linear solver type Tv System Backend Method\nDense_SymPosDef Real Normal equations Dense / LAPACK Cholesky\nCholmod_SymQuasDef Float64 Augmented system CHOLMOD LDLᵀ\nCholmod_SymPosDef Float64 Normal equations CHOLMOD Cholesky\nLDLFact_SymQuasDef Real Augmented system LDLFactorizations.jl LDLᵀ\nKrylovSPDSolver Real Normal equations Krylov.jl Krylov\nKrylovSIDSolver Real Augmented system[1] Krylov.jl Krylov\nKrylovSQDSolver Real Augmented system[1] Krylov.jl Krylov","category":"page"},{"location":"manual/linear_systems/","page":"Solving linear systems","title":"Solving linear systems","text":"[1]: KrylovSIDSolvers view the augmented system as a symmetric indefinite system, while KrylovSQDSolvers exploit its 2x2 structure and quasi-definite property. See the reference documentation for more details.","category":"page"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"CurrentModule = Tulip","category":"page"},{"location":"reference/attributes/#Attribute-reference","page":"Attributes","title":"Attribute reference","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Attributes are queried using get_attribute and set using set_attribute.","category":"page"},{"location":"reference/attributes/#Model-attributes","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nModelName String Name of the model\nNumberOfConstraints Int Number of constraints in the model\nNumberOfVariables Int Number of variables in the model\nObjectiveValue Tv Objective value of the current primal solution\nDualObjectiveValue Tv Objective value of the current dual solution\nObjectiveConstant Tv Value of the objective constant\nObjectiveSense  Optimization sense\nStatus  Model status\nBarrierIterations Int Number of barrier iterations\nSolutionTime Float64 Solution time, in seconds","category":"page"},{"location":"reference/attributes/#Variable-attributes","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nVariableLowerBound Tv Variable lower bound\nVariableUpperBound Tv Variable upper bound\nVariableObjectiveCoeff Tv Variable objective coefficient\nVariableName String Variable name","category":"page"},{"location":"reference/attributes/#Constraint-attributes","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Name Type Description\nConstraintLowerBound Tv Constraint lower bound\nConstraintUpperBound Tv Constraint upper bound\nConstraintName String Constraint name","category":"page"},{"location":"reference/attributes/#Reference","page":"Attributes","title":"Reference","text":"","category":"section"},{"location":"reference/attributes/#Model-attributes-2","page":"Attributes","title":"Model attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/Core/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractModelAttribute","category":"page"},{"location":"reference/attributes/#Tulip.BarrierIterations","page":"Attributes","title":"Tulip.BarrierIterations","text":"BarrierIterations\n\nNumber of iterations of the barrier algorithm in the last call.\n\nThis number may be zero in the following cases:\n\nthe model has been solved yet\npresolve solved the model\nthe initial solution was optimal\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.BarrierIterations())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.DualObjectiveValue","page":"Attributes","title":"Tulip.DualObjectiveValue","text":"DualObjectiveValue\n\nObjective value of the current dual solution.\n\nType: Tv\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.DualObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ModelName","page":"Attributes","title":"Tulip.ModelName","text":"ModelName\n\nThe name of the model.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ModelName(), \"lp_example\")\nTulip.get_attribute(model, Tulip.ModelName())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfConstraints","page":"Attributes","title":"Tulip.NumberOfConstraints","text":"NumberOfConstraints\n\nNumber of constraints in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfConstraints())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.NumberOfVariables","page":"Attributes","title":"Tulip.NumberOfVariables","text":"NumberOfVariables\n\nNumber of variables in the model.\n\nType: Int\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.NumberOfVariables())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveConstant","page":"Attributes","title":"Tulip.ObjectiveConstant","text":"ObjectiveConstant\n\nConstant objective offset, defaults to zero.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ObjectiveConstant(), zero(Tv))\nTulip.get_attribute(model, Tulip.ObjectiveConstant())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveSense","page":"Attributes","title":"Tulip.ObjectiveSense","text":"ObjectiveSense\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ObjectiveValue","page":"Attributes","title":"Tulip.ObjectiveValue","text":"ObjectiveValue\n\nObjective value of the current primal solution.\n\nType: Tv\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.ObjectiveValue())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.SolutionTime","page":"Attributes","title":"Tulip.SolutionTime","text":"SolutionTime\n\nTotal solution time, in seconds.\n\nType: Float64\n\nModifiable: No\n\nExamples\n\nTulip.get_attribute(model, Tulip.SolutionTime())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.Status","page":"Attributes","title":"Tulip.Status","text":"Status\n\nModel status\n\nType:\n\nModifiable: No\n\nExamples\n\nTulip.get(model, Tulip.Status())\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Variable-attributes-2","page":"Attributes","title":"Variable attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/Core/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractVariableAttribute","category":"page"},{"location":"reference/attributes/#Tulip.VariableLowerBound","page":"Attributes","title":"Tulip.VariableLowerBound","text":"VariableLowerBound\n\nVariable lower bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableLowerBound(), 1, zero(Tv))\nTulip.get_attribute(model, Tulip.VariableLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableName","page":"Attributes","title":"Tulip.VariableName","text":"VariableName\n\nName of the variable.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableName(), 1, \"x1\")\nTulip.get_attribute(model, Tulip.VariableName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableObjectiveCoeff","page":"Attributes","title":"Tulip.VariableObjectiveCoeff","text":"VariableObjectiveCoeff\n\nObjective coefficient of the variable.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableObjectiveCoeff(), 1, one(Tv))\nTulip.get_attribute(model, Tulip.VariableObjectiveCoeff(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.VariableUpperBound","page":"Attributes","title":"Tulip.VariableUpperBound","text":"VariableUpperBound\n\nVariable upper bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.VariableUpperBound(), 1, one(Tv))\nTulip.get_attribute(model, Tulip.VariableUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Constraint-attributes-2","page":"Attributes","title":"Constraint attributes","text":"","category":"section"},{"location":"reference/attributes/","page":"Attributes","title":"Attributes","text":"Modules = [Tulip]\nPages = [\"src/Core/attributes.jl\"]\nFilter = t -> typeof(t) === DataType && t <: Tulip.AbstractConstraintAttribute","category":"page"},{"location":"reference/attributes/#Tulip.ConstraintLowerBound","page":"Attributes","title":"Tulip.ConstraintLowerBound","text":"ConstraintLowerBound\n\nConstraint lower bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintLowerBound(), 1, zero(Tv))\nTulip.get_attribute(model, Tulip.ConstraintLowerBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintName","page":"Attributes","title":"Tulip.ConstraintName","text":"ConstraintName\n\nName of the constraint.\n\nType: String\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintName(), 1, \"c1\")\nTulip.get_attribute(model, Tulip.ConstraintName(), 1)\n\n\n\n\n\n","category":"type"},{"location":"reference/attributes/#Tulip.ConstraintUpperBound","page":"Attributes","title":"Tulip.ConstraintUpperBound","text":"ConstraintUpperBound\n\nConstraint upper bound.\n\nType: Tv\n\nModifiable: Yes\n\nExamples\n\nTulip.set_attribute(model, Tulip.ConstraintUpperBound(), 1, one(Tv))\nTulip.get_attribute(model, Tulip.ConstraintUpperBound(), 1)\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Tulip","category":"page"},{"location":"#Tulip.jl","page":"Home","title":"Tulip.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is an open-source interior-point solver for linear programming.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tulip is 100% Julia, so install it just like any Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add Tulip","category":"page"},{"location":"","page":"Home","title":"Home","text":"No additional building step is required.","category":"page"},{"location":"#Citing-Tulip.jl","page":"Home","title":"Citing Tulip.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use Tulip in your work, we kindly ask that you cite the following reference. The PDF is freely available here, and serves as a user manual for advanced users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@TechReport{Tulip.jl,\n    title = {{Tulip}.jl: an open-source interior-point linear optimization\n    solver with abstract linear algebra},\n    url = {https://www.gerad.ca/fr/papers/G-2019-36},\n    Journal = {Les Cahiers du Gerad},\n    Author = {Anjos, Miguel F. and Lodi, Andrea and Tanneau, Mathieu},\n    year = {2019}\n}","category":"page"}]
}
